# scRNA-seq
This pipeline performs quality control and data cleaning for single-cell RNA sequencing (scRNA-seq), compatible with 3' scRNA-seq, 5' scRNA-seq, and single-nucleus RNA-seq (snRNA-seq) data.  

## Part I Workflow
As illustrated in the figure,  
(i) yellow circles represent the steps where commands need to be entered;  
(ii) pink dashed rectangular boxes represent the output results after processing at each step.  
![image](https://github.com/user-attachments/assets/ccef0d00-c140-4422-ba21-ebdd44a7b063)  

## Part II Pre-processing
Before processing scRNA-seq raw data, you need to set up the Cell Ranger software and use cellranger mkref to build a reference genome index for alignment.  
### i.Conda Environment
```
conda install hcc::cellranger
```
### ii.Index Prepared
```
cellranger mkref --genome=GRCh38 \
   --fasta=/mnt/share/FileTransfer/GRCh38.primary_assembly.genome.fa \
   --genes=/mnt/share/FileTransfer/gencode.v47.annotation.gtf \
   --nthreads=30 >GRCh38.mkref.log &
```

## Part III Generation of Data for Analysis
### i.Raw Data Quality Check(QC) & Mapping Data to Genome
```
cellranger count --id=Control1 --localcores=30 \
   --fastqs=/mnt/project/scASI/10X/E-MATB-10378/1.rawdata/ \
   --sample=Control1 \
   --transcriptome=/mnt/project/scASI/GRCh38 \
   --nosecondary \
   --chemistry SC5P-PE > Control1.log &
```
#### Determining Data Usability
High-quality scRNA-seq raw data must meet the following standards. Data failing to satisfy these criteria indicate poor quality and should be excluded from downstream analysis.  
The following are three sections of metrics from the QC report generated by CellRanger, found in the web_summary.html file.  
#### • Summary part  
![image](https://github.com/user-attachments/assets/99200b58-8963-4d65-b4b8-01646423e525)  
(i) Estimated Number of Cells: >3000  
Estimated Number of Cells: the number of barcodes associated with cells.  
If the number of cells in the experiment is known, the discrepancy between Estimated Number of Cells and the expected number of cells in the experiment: >50% & <200%  
(ii) Mean Reads per Cell: >20,000  
Mean Reads per Cell: the total number of sequenced reads divided by the number of cells.  
(iii) Median Genes per Cell: >800  
Median Genes per Cell: the median number of genes detected per cell-associated barcode. This metric is dependent on cell type and sequencing depth. 
#### • Sequencing part  
![image](https://github.com/user-attachments/assets/dcc69310-811e-45c5-af02-67f7def20bd0)  
(i) Q30 Bases in Barcode: >80%  
This metric indicates the percentage of bases in the barcode sequences that have a Phred quality score of 30 or higher. A Q30 score means there is a 1 in 1,000 chance of an incorrect base call (99.9% accuracy).
(ii) Q30 Bases in RNA Read: >60%  
This shows the percentage of bases in the RNA portion of the read that also have a Q30 score or higher. 
#### • Mapping part  
![image](https://github.com/user-attachments/assets/9e280989-4a27-4c14-9be7-8f9e9db66c48)  
(i) Reads Mapped to Genome: >85%  
This metric represents the percentage of reads that successfully align to the reference genome. If most sequencing reads align with known genomic sequences, it indicates high data quality and good sequencing performance. This metric is important.  
(ii) Reads Mapped Confidently to Exonic Regions: >60%  
This metric represents the percentage of reads that confidently map to exonic regions (the protein-coding parts of genes).  

### ii.Remove low-quality cells and genes
```
dir<-" " #the directory of data
pbmc.data<-Read10X(data.dir=dir)
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
expr_mat <- GetAssayData(pbmc, slot = "counts")
genes_use <- rowSums(expr_mat > 0) > 0.05 * ncol(pbmc)
pic<-VlnPlot(pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```
![image](https://github.com/user-attachments/assets/fe68f2e3-bcde-42cd-89fd-0a4910966ce4)  
#### • The standards for high-quality cells and genes  
(i) Number of counts: >1500 (scRNA-seq) >1000 (snRNA-seq)  
(ii) Number of genes: >700 (scRNA-seq) >500 (snRNA-seq)  
(iii) Percent of mitochondrial transcripts: <15% (scRNA-seq) <10% (snRNA-seq)  
Filtering criteria for some exception cell types (scRNA-seq):  
Cardiac muscle cells, Skeletal muscle cells, Aged cells: <50%  
Neurons, Cancer cells: No filtering  
(iv) Number of cells in which gene is present: >5%  

```
pbmc <- subset(pbmc, subset = nCount_RNA > 1500 &
                 nFeature_RNA > 700 & 
                 percent.mt < 15)
pbmc <- subset(pbmc, features = rownames(expr_mat)[genes_use])
```
(v) Remove doublets  
Choose the appropriate Expected Doublet Rate to replace the number in nExp_poi.  
| Total Cells | Expected Doublet Rate |
|-------------|------------------------|
| ~500        | 0.004 (0.4%)           |
| ~1000       | 0.008 (0.8%)           |
| ~2000       | 0.016 (1.6%)           |
| ~3000       | 0.024 (2.4%)           |
| ~4000       | 0.032 (3.2%)           |
| ~5000       | 0.040 (4.0%)           |
| ~6000       | 0.048 (4.8%)           |
| ~7000       | 0.056 (5.6%)           |
| ~8000       | 0.064 (6.4%)           |
| ~9000       | 0.072 (7.2%)           |
| ~10000      | 0.080 (8.0%)           |
```
pbmc <- NormalizeData(pbmc, normalization.method = "LogNormalize", scale.factor = 10000)
pbmc <- FindVariableFeatures(pbmc, selection.method = "vst", nfeatures = 2000)
pbmc <- ScaleData(pbmc)
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
pbmc <- RunUMAP(pbmc, dims = 1:10)
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
pbmc <- RunUMAP(pbmc, dims = 1:10)

sweep.res.list <- paramSweep(pbmc, PCs = 1:10, sct = FALSE)
sweep.stats <- summarizeSweep(sweep.res.list, GT = FALSE)
bcmvn <- find.pK(sweep.stats)  #choose the best pK
annotations <- pbmc@meta.data$seurat_clusters
homotypic.prop <- modelHomotypic(annotations)
nExp_poi <- round(0.056 * nrow(pbmc@meta.data))  # 0.056 is the expected doublet rate for ~7000 cells
nExp_poi.adj <- round(nExp_poi * (1 - homotypic.prop))

pbmc <- doubletFinder(pbmc, PCs = 1:10, pN = 0.25, pK = 0.09, nExp = nExp_poi, reuse.pANN = FALSE, sct = FALSE)
pANN_col <- grep("pANN", colnames(pbmc@meta.data), value = TRUE)
pbmc <- doubletFinder(pbmc, PCs = 1:10, pN = 0.25, pK = 0.09, nExp = nExp_poi.adj, reuse.pANN = pANN_col, sct = FALSE)
doublet_col <- grep("DF.classifications", colnames(pbmc@meta.data), value = TRUE)
colnames(pbmc@meta.data)[which(colnames(pbmc@meta.data) == doublet_col)] <- "Doublet"

pbmc <- subset(pbmc, subset = Doublet == "Singlet")
```








